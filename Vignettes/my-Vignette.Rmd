---
title: "ROCpAI: ROC Partial Area Indexes for evaluating classifiers"
author:
- name: "Manuel Franco"
  affiliation: &deio Department of Statistics and Operations Research, University of Murcia, IMIB-Arrixaca, 30100, Murcia, Spain
- name: "Juana-María Vivo"
  affiliation: *deio
- name: "Juan Pedro García-Ortiz"
  affiliation: *deio
package: ROCpAI
date: "2020-01-15"
bibliography: ROCpAI.bib
biblio-style: apsr
link-citations: yes

abstract: >
  R package **ROCpAI** how-to guide

output: 
  BiocStyle::html_document:
    toc_float: true
vignette: >
  %\VignetteIndexEntry{ROC Partial Area Indexes for evaluating classifiers}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}  
---

```{r style, include=FALSE, results='hide'}
BiocStyle::markdown()
library(boot)
library(fission)
library(SummarizedExperiment)
```

```{r, include=FALSE, results='hide'}
portion_ROC <- function(up.limit, low.limit, fpr.roc,sen.roc){

  i.low<-min(which(fpr.roc >= low.limit))
  j.low<-max(i.low-1, 1)
  i.up<-max(which(fpr.roc <= up.limit))
  j.up<-min(1+i.up, length(fpr.roc))
  fpr.proc<-fpr.roc[i.low:i.up]
  sen.proc<-sen.roc[i.low:i.up]
  if (fpr.roc[i.low] > low.limit) {
    fpr.proc<-append(fpr.proc, low.limit, 0)
    sen.proc<-append(sen.proc, sen.roc[j.low]+(sen.roc[i.low]-sen.roc[j.low])*(fpr.proc[1]-fpr.roc[j.low])/(fpr.roc[i.low]-fpr.roc[j.low]), 0)}
  if (fpr.roc[i.up] < up.limit) {
    fpr.proc<-append(fpr.proc, up.limit, length(fpr.proc))
    sen.proc<-append(sen.proc, sen.roc[j.up]-(sen.roc[j.up]-sen.roc[i.up])*(fpr.roc[j.up]-fpr.proc[length(fpr.proc)])/(fpr.roc[j.up]-fpr.roc[i.up]), length(sen.proc))}

  return(cbind(fpr.proc, sen.proc))
}

classification_Tp <- function(fpr.proc,sen.proc){

  if (all(sen.proc>=fpr.proc)) {
    proper.proc<-TRUE} else {proper.proc<-FALSE}
  plr.proc<-(sen.proc-sen.proc[1])/(fpr.proc-fpr.proc[1])
  plr.proc<-plr.proc[is.finite(plr.proc)]
  if (all(plr.proc>=plr.proc[length(plr.proc)])) {
    plr.proc.bounded<-TRUE} else {plr.proc.bounded<-FALSE}

  classification <- c(plr.proc.bounded,proper.proc)

  return(classification)
}

#Tighter partial area under a portion
TpA <- function(fpr.proc, sen.proc){
  pA.roc <- pA(fpr.proc, sen.proc)
  type_roc <- classification_Tp(fpr.proc, sen.proc)

  min.pAUC<-sum(diff(fpr.proc^2))/2
  max.pAUC<-sum(diff(fpr.proc))
  TpAUC.max.roc<-max.pAUC*max(sen.proc)

  if (min(sen.proc) == max(sen.proc) ) {
    TpAUC.min.roc =0} else {
      if (type_roc[1]) {
        TpAUC.min.roc<-sum(diff(fpr.proc))*mean(c(min(sen.proc), max(sen.proc)))
        } else {

        if (type_roc[2]) {
            TpAUC.min.roc<-max(max.pAUC*min(sen.proc), min.pAUC)
          } else {TpAUC.min.roc<-max.pAUC*min(sen.proc)}
        }
      }
  if (min(fpr.proc) == max(fpr.proc) ) { TpAUC.max.roc = 1}

  if (max(sen.proc)!=0 )
  {TpA.roc<-(1+((pA.roc-TpAUC.min.roc)/(TpAUC.max.roc-TpAUC.min.roc)))/2} else {TpA.roc=0}

  return(TpA.roc)

}
#Calculate the partial area under a portion
pA <- function(fpr.proc,sen.proc){
  aux <- sum(diff(fpr.proc)*
              apply(cbind(sen.proc[-1],
                          sen.proc[-length(sen.proc)]), 1, mean))
  return(aux)
}

#McClish partial area under a portion
MCpA <- function(sen.proc,fpr.proc){
  pA.roc <- pA(fpr.proc, sen.proc)
  type_roc <- classification_Tp(fpr.proc, sen.proc)

  max.pAUC <- sum(diff(fpr.proc))
  min.pAUC <- sum(diff(fpr.proc^2))/2

  if (type_roc[2]) {
    if (min(fpr.proc) == max(fpr.proc) ) { max.pAUC = 1}

            MCpA.roc<-(1+((pA.roc-min.pAUC)/(max.pAUC-min.pAUC)))/2
    } else {
      MCpA.roc<-NA}

  return(MCpA.roc)
}

fbootT<- function(dataset,bssample, low.limit, up.limit){
  SpAUC <- NULL
  bsdata <- dataset[bssample,]
  for (i in 2:dim(bsdata)[2]) {
    bsdata_temp <- cbind(bsdata[,1],bsdata[,i])
    sen.roc<- points_curve(bsdata_temp[,1],bsdata_temp[,2])[,2]
    fpr.roc<- points_curve(bsdata_temp[,1],bsdata_temp[,2])[,1]

    fpr.proc <- portion_ROC(up.limit, low.limit, fpr.roc,sen.roc)[,1]

    sen.proc <- portion_ROC(up.limit, low.limit, fpr.roc,sen.roc)[,2]
    SpAUC[i-1] <- TpA(fpr.proc,sen.proc)
    
  }
  return(SpAUC)
}

fbootM<- function(dataset,bssample, low.limit, up.limit){
  SpAUC <- NULL
  bsdata <- dataset[bssample,]
  for (i in 2:dim(bsdata)[2]) {
    bsdata_temp <- cbind(bsdata[,1],bsdata[,i])
    sen.roc<- points_curve(bsdata_temp[,1],bsdata_temp[,2])[,2]
    fpr.roc<- points_curve(bsdata_temp[,1],bsdata_temp[,2])[,1]

    fpr.proc <- portion_ROC(up.limit, low.limit, fpr.roc,sen.roc)[,1]

    sen.proc <- portion_ROC(up.limit, low.limit, fpr.roc,sen.roc)[,2]
    SpAUC[i-1] <- MCpA(sen.proc,fpr.proc)


  }
  return(SpAUC)
}

createSE <- function(object, names){
  names(object) <- names
  names <- names

  data.matrix <- as.matrix(object)
  
  se=SummarizedExperiment::SummarizedExperiment(assays=data.matrix,
                          colData<-data.frame(metrics = (names)))
  names(se@assays@data@listData[[1]]) <- names
  return(se)
}
```


# Introduction #

The **ROCpAI** package allows to calculate the area under the ROC curve (AUC)
and the partial area under the  ROC curve (pAUC) as well as partial area indexes related with the pAUC over a restricted false positive interval of interest even if the ROC curve is improper. 

To do this, the package calculates the specificty and sensibility from a classification model with the function **points.curve**, after that, it calculates the partia area and two standardized: the McClish index [@McClish1989] with the **McpAUC** if the ROC curve is proper over the restricted interval, and the **TpAUC** index according for any shape of the ROC curve over such interval, even if it is improper.
Moreover,the functions **TpAUCboot** and **MCpAUCboot** apply bootstrap resampling [@DavisonHinkley1997] to calculate the empiral standard deviation and the confidence interval of these standardized indexes.

## Installation ##

The installation of **ROCpAI** package is performed via Github:
```{r installation, eval=FALSE}
devtools::install_github("juanpegarcia/ROCpAI")
```

## Prerequisites ##

The package **ROCpAI** depends on the following Bioconductor package:
`SummarizedExperiment` [@SummarizedExperiment2019] and `boot` [@boot2019], 

# Using ROCpAI #

The  **fission** dataset [@Leongetal2014] contains the data of 36 samples of yeast and 7039 genes in a RangedSummarizedExperiment object type. These 36 samples are divided in 18 native samples and 18 mutated samples.

```{r, echo=FALSE, include=FALSE, results='hide'}
library(fission)
library(ROCpAI)

data("fission")
fission.expresion <- assay(fission)
fission.expresion <- t(fission.expresion)
strain <- fission@colData@listData$strain

fission.genes.10 <- fission.expresion[,c("SPNCRNA.1080","SPAC186.08c","SPNCRNA.1420","SPCC70.08c","SPAC212.04c")]

genes <- cbind(strain,fission.genes.10)
colnames(genes) <- c("Strain", "Gene1", "Gene2", "Gene3", "Gene4", "Gene5"  )

```

Data.frame example
```{r}
genes 
```


# Functions: #

##  Point_Curves ##

This function generates the points of the ROC curve given by the pairs of the true positive rate (sensitibity) and false positive rate (1-specificity) for each possible cut-off point. **points_curve** needs 2 parameters: x and y. The first parameter correspond to a vector with the cases’ tags, while the second one is a vector with the value of each case. This function returns a matrix with the sensibility and specifity.

```{r, echo=FALSE}
points_curve<-function(x, y){
  xsample <- NULL; ysample <- NULL
  xsample <- cbind(x[which(is.na(x)==FALSE & is.na(y)==FALSE)])
  ysample <- y[which(is.na(x)==FALSE & is.na(y)==FALSE)]
  points<-NULL; pre.point<-NULL; fpr.point<-NULL; sen.point<-NULL; xy<-NULL
  points<-sort(ysample)
  points<-append(points[-length(points)]+diff(points)/2, min(points)-1, 0)
  points<-append(points, max(ysample)+1, length(points))
  for (point in points) {
    pre.point<-(ysample>point)*1
    fpr.point[which(points == point)]<-sum((pre.point == 1)*(xsample == 1))/sum(xsample == 1)
    sen.point[which(points == point)]<-sum((pre.point == 1)*(xsample == 2))/sum(xsample == 2)

  }
  if (is.unsorted(sen.point)) {
    sen.point<-rev(sen.point)
    fpr.point<-rev(fpr.point)}
  xy<-cbind(fpr.point, sen.point)
  return(xy)
}

```

```{r}
points_curve(genes[,1], genes[,2])
```




## McpAUC ##

This function calculates the pAUC its standardised partial area index given by [@McClish1989]. This function has five parameters. The first one is a data.frame or a RangedSummarizedExperiment object, if it is a data.frame object, the "Gold Standard" must be in the first column. The other four parameters are optionals; low.value and up.value are the false positive rate values that the function will use to calculate the pAUC. If low.value is NULL the function will take 0 as the lower limit. If up.value is NULL the function will use 1 as the upper value. The parameter plot generates a graph with the ROC curves generated. The last parameter is called "selection" and is only used if the parameter "dataset" is a RangedSummarizedExperiment object. This parameter is used to select the variables that will be analysed. If this parameter is NULL the function will analyse all the variables in the dataset.
The function returns as RangedSummarizedExperiment object with the pAUC and the McpAUC scores,and the TPR and FPR values for each ROC curve generated.

```{r, echo=FALSE}
McpAUC <- function(dataset,  low.value=NULL, up.value=NULL, plot=FALSE, selection = NULL) {
  St_pAUC <-NULL; pAUC <- NULL; sensitivity <- NULL; FPR <- NULL;
  fpr.proc<-NULL; sen.proc<-NULL;  up.limit <- NULL; low.limit <- NULL
  Ap.roc<-NULL;   object <- NULL;par(new=FALSE);  par <- NULL; legend <- NULL; abline <- NULL;

  if (class(dataset)=="RangedSummarizedExperiment") {
    strain <- dataset@colData@listData$strain
    dataset <- as.data.frame(SummarizedExperiment::assay(dataset))
    dataset <- scale(t(as.matrix(dataset[selection,])), center=TRUE, scale = TRUE)
    name.variable <- colnames(dataset)
    dataset <- as.data.frame(cbind(strain,dataset))
  }  else {  dataset <- as.data.frame(dataset)
  name.variable <- colnames(dataset)
  }
  dimension <- dim(dataset)

  if(dimension[2]<2) {stop("database has to have at least 2 colums")}


  for (i in 2:dimension[2]) {
    dataset_temporal <- cbind(dataset[,1],dataset[i])
    sen.roc<- points_curve(dataset_temporal[,1],dataset_temporal[,2])[,2]
    fpr.roc<- points_curve(dataset_temporal[,1],dataset_temporal[,2])[,1]

    ## Variables and initial values for the partial area of each ROC curve
    ### PARTIAL ROC curve (fpr.proc; sen.proc) on [lower.fp <= e <= upper.fp]

    if (!is.null(up.value)){up.limit <- up.value}else{up.limit <- 1}
    if (!is.null(low.value)){low.limit <- low.value}else{low.limit <- 0}
    fpr.proc <- portion_ROC(up.limit, low.limit, fpr.roc,sen.roc)[,1]
    sen.proc <- portion_ROC(up.limit, low.limit, fpr.roc,sen.roc)[,2]

    ### TYPE OF PORTION ROC curve on [lower.fp <= e <= upper.fp]

    ### BOUNDS FOR PARTIAL AREA INDEXES: MIN & MAX boundaries for TpAUC index
    St_pAUC[[i-1]] <- MCpA(sen.proc,fpr.proc)
    pAUC[[i-1]] <- as.vector(pA(fpr.proc,sen.proc))
    sensitivity[[i-1]] <-as.vector(sen.proc)
    FPR[[i-1]] <- as.vector(fpr.proc)
    if (isTRUE(plot)) {plot(sen.roc~fpr.roc, type="l", col=i, ylab="TPR", xlab="FPR")
      legend(x= "bottomright",legend = name.variable[1:i-1], fill = 2:i, cex = 0.8)
      abline(a=c(0,1),lwd=1, col="grey")
      abline(v=low.value,col="black")
      abline(v=up.value,col="black")
      par(new=TRUE)

    }

  }

  object <- list(St_pAUC, pAUC, sensitivity, FPR)
  names <- c("St_pAUC","pAUC", "Sensitivity", "FPR")
  se <- createSE(object, names)
  return(se)
}

```

```{r}
resultMc <- McpAUC(genes, low.value = 0, up.value = 0.25, plot=TRUE)
resultMc
```
```{r}
test.Mc<- assay(resultMc)
test.Mc$St_pAUC
```

```{r}
test.Mc$pAUC
```


## TpAUC ##

This function calculates the pAUC and its standardised pAUC by the tighter partial area index (TpAUC) [@Vivoetal2018]. This function has five parameters. The first one is a data.frame or a RangedSummarizedExperiment object, if it is a data.frame object the "Gold Standard" must be in the first column. The other four parameters are optionals; low.value and up.value are the false positive rate values that the function will use to calculate the pAUC. If low. value is NULL the function will take 0 as the lower limit. If up.value is NULL the function will use 1 as the upper value. The parameter plot generates a graph for each ROC curve generated. The last parameter is called "selection" and is only used if the parameter "dataset" is a RangedSummarizedExperiment object. This parameter is used to select the variables that will be analysed. If this parameter is NULL the function will do a ROC curve with all the variables in the object.
The function returns as RangedSummarizedExperiment object with the pAUC and the TpAUC scores,and the TPR and FPR values for each ROC curve generated

```{r, echo=FALSE}
TpAUC <- function(dataset,  low.value = NULL, up.value = NULL, plot = FALSE, selection = NULL ) {
  St_pAUC <-NULL; pAUC <- NULL; sensitivity <- NULL; FPR <- NULL;
  fpr.proc<-NULL; sen.proc<-NULL;  up.limit <- NULL; low.limit <- NULL
  Ap.roc<-NULL;   object <- NULL;  par <- NULL; legend <- NULL; abline <- NULL;
    ## Variables and initial values for each sample<-ROC curve

  if (class(dataset)=="RangedSummarizedExperiment") {
    strain <- dataset@colData@listData$strain
    dataset <- as.data.frame(SummarizedExperiment::assay(dataset))
    dataset <- scale(t(as.matrix(dataset[selection,])), center=TRUE, scale = TRUE)
    name.variable <- colnames(dataset)
    dataset <- as.data.frame(cbind(strain,dataset))
  }  else {  dataset <- as.data.frame(dataset)
  name.variable <- colnames(dataset)
  }
  dimension <- dim(dataset)

  if(dimension[2]<2) {stop("database has to have at least 2 colums")}


  for (i in 2:dimension[2]) {
    dataset_temporal <- cbind(dataset[,1],dataset[i])
    sen.roc<- points_curve(dataset_temporal[,1],dataset_temporal[,2])[,2]
    fpr.roc<- points_curve(dataset_temporal[,1],dataset_temporal[,2])[,1]

    if (!is.null(up.value)){up.limit <- up.value}else{up.limit <- 1}
    if (!is.null(low.value)){low.limit <- low.value}else{low.limit <- 0}
    fpr.proc <- portion_ROC(up.limit, low.limit, fpr.roc,sen.roc)[,1]
    sen.proc <- portion_ROC(up.limit, low.limit, fpr.roc,sen.roc)[,2]

    St_pAUC[[i-1]] <- TpA(fpr.proc,sen.proc)
    pAUC[[i-1]] <- as.vector(pA(fpr.proc,sen.proc))
    sensitivity[[i-1]] <-as.vector(sen.proc)
    FPR[[i-1]] <- as.vector(fpr.proc)
    if (isTRUE(plot)) {plot(sen.roc~fpr.roc, type="l", col=i, ylab="TPR", xlab="FPR")
      legend(x= "bottomright",legend = name.variable[1:i-1], fill = 2:i, cex = 0.8)
      abline(a=c(0,1),lwd=1, col="grey")
      abline(v=low.value,col="black")
      abline(v=up.value,col="black")
      par(new=TRUE)

      }
  }
  object <- list(St_pAUC, pAUC, sensitivity, FPR)
  names <- c("St_pAUC","pAUC", "Sensitivity", "FPR")
  se <- createSE(object, names)
  return(se)

}
```

```{r}
resultsT <- TpAUC(genes, low.value = 0, up.value = 0.25, plot=TRUE)
resultsT
```
```{r}
test.TpAUC <- assay(resultsT)

```
```{r}
test.TpAUC$St_pAUC

```
```{r}
test.TpAUC$pAUC
```

## TpAUCboot ##

This function use the R package `boot` to calculate the variability of the TpAUC for each classifier over the restricted fpr interval of interest, and its confidence interval based on the methods of the boot.ci function. The TpAUCboot function uses 7 parameters: dataset,  low.value, up.value, r, seed, level and type.interval. Dataset is a matrix or a SummarizedExperiment object. The first column must be the condition of each case, while the following columns are the values of the variables or classifiers. The **low.value** and **up.value** are the FPR limits for the pAUC. The parameter **r** is the name of iterations. The parameter **level** is the value used for the confidence interval (per default is 0.95) and the **type.interval** defines the method applied by boot.ci, which can be "norm", "basic", "stud", "perc" or "bca". The last parameter is called "selection" and is only used if the parameter "dataset" is a RangedSummarizedExperiment object. This parameter is used to select the genes that will be analysed. If this parameter is NULL, the function will display a ROC curve with all the variables in the object.
This function returns a SummarizedExperiment object with the TpAUC, the standard desviation, and the lower and upper limits of the confidence interval

```{r, echo=FALSE}
TpAUCboot <- function(dataset,  low.value = NULL, up.value = NULL,
                      r=50, seed=NULL, level = 0.95, type.interval="perc", selection = NULL) {

  ci_TpAUC <- NULL; CpA=NULL;ci_MCpAUC <- NULL; sd <- NULL; par <- NULL; legend <- NULL; abline <- NULL;

  if (class(dataset)=="RangedSummarizedExperiment") {
    strain <- dataset@colData@listData$strain
    dataset <- as.data.frame(SummarizedExperiment::assay(dataset))
    dataset <- scale(t(as.matrix(dataset[selection,])), center=TRUE, scale = TRUE)
    name.variable <- colnames(dataset)
    dataset <- as.data.frame(cbind(strain,dataset))
  }  else {  dataset <- as.data.frame(dataset)  }

  if(dim(dataset)[2]<2) {stop("database has to have at least 2 colums")}
  if (!is.null(up.value)){
    up.limit <- up.value
  }else{
    up.limit <- 1
  }
  if (!is.null(low.value)){
    low.limit <- low.value
  }else{
    low.limit <- 0
  }
  if(is.null(seed)){
    old.seed <- .Random.seed
    on.exit({.Random.seed <- old.seed})
  }

  result_boot <- boot::boot(dataset, statistic = fbootT, R=r, low.limit = low.limit, up.limit =up.limit)

  intervalo_confianza <- matrix(0,nrow=dim(result_boot$t)[2],ncol=4)
  for (i in 1:dim(result_boot$t)[2]) {
    ci_TpAUC <- boot::boot.ci(result_boot, type <- type.interval, conf = level, index = i )
    p_max=length(ci_TpAUC[[4]])
    intervalo_confianza[i,]=c(result_boot$t0[i],ci_TpAUC[[4]][c(p_max-1,p_max)],sd(result_boot$t[,i]))
  }
  colnames(intervalo_confianza)=c("Tp_AUC","lwr","upr","sd")
  names <- c("Tp_AUC","lwr","upr","sd")
  obj <- list(intervalo_confianza[,1],intervalo_confianza[,2],intervalo_confianza[,3],intervalo_confianza[,4])
  x <- createSE(obj, names)

  return(x)

}
```

```{r, warning='hide'}
resultstboot<- TpAUCboot(genes,low.value = 0, up.value = 0.25, seed = 1234)
```

```{r, echo='hide'}
test.TpAUCboot <- assay(resultstboot)
resultT <- t(as.data.frame(cbind(test.TpAUCboot$Tp_AUC,test.TpAUCboot$sd,test.TpAUCboot$lwr,test.TpAUCboot$upr)))
colnames(resultT) <- c("Gene1", "Gene2", "Gene3", "Gene4", "Gene5")
rownames(resultT) <- c("Tp_AUC","sd","lwr","upr")
```
```{r}
resultT
```

## MCpAUCboot ##

This function use the R package `boot` to calculate the variability of the MCpAUC for each classifier over the restricted fpr interval of interest, and its confidence interval based on the methods of the boot.ci function. The MCpAUCboot function uses 7 parameters: dataset, low.value, up.value, r, seed, level and type.interval. Dataset is a matrix or a SummarizedExperiment object. The first column must be the condition of each case, while the following columns are the values of the variables or classifiers. The **low.value** and **up.value** are the FPR limits for the pAUC.The parameter **r** is the name of iterations. The parameter **level** is the value used for the confidence interval (per default is 0.95) and the **type.interval** defines the method applied by boot.ci, which can be "norm", "basic", "stud", "perc" or "bca". The last parameter is called "selection" and is only used if the parameter "dataset" is a RangedSummarizedExperiment object. This parameter is used to select the genes that will be analysed. If this parameter is NULL, the function will display a ROC curve with all the variables in the object.
This function returns a SummarizedExperiment object with the MCpAUC, the standard desviation, and the lower and upper limits of the confidence interval.

```{r, echo=FALSE}
MCpAUCboot <- function(dataset,  low.value = NULL, up.value = NULL,
                       r=50, seed=NULL, level = 0.95, type.interval="perc", selection = NULL) {

  ci_MCpAUC <- NULL; sd <- NULL; par <- NULL; legend <- NULL; abline <- NULL;

  if (class(dataset)=="RangedSummarizedExperiment") {
    strain <- dataset@colData@listData$strain
    dataset <- as.data.frame(SummarizedExperiment::assay(dataset))
    dataset <- scale(t(as.matrix(dataset[selection,])), center=TRUE, scale = TRUE)
    name.variable <- colnames(dataset)
    dataset <- as.data.frame(cbind(strain,dataset))
  } else {  dataset <- as.data.frame(dataset)  }

  if(dim(dataset)[2]<2) {stop("database has to have at least 2 colums")}
  if (!is.null(up.value)){
    up.limit <- up.value
  }else{
    up.limit <- 1
  }
  if (!is.null(low.value)){
    low.limit <- low.value
  }else{
    low.limit <- 0
  }
  if(is.null(seed)){
    old.seed <- .Random.seed
    on.exit({.Random.seed <- old.seed})
  }

  McpNA <-assay(McpAUC(dataset, low.value=low.value, up.value = up.value ))$St_pAUC

  result_boot <- boot::boot(dataset, statistic = fbootM, R=r, low.limit = low.limit, up.limit =up.limit)
  intervalo_confianza <- matrix(0,nrow=dim(result_boot$t)[2],ncol=4)
  for (i in 1:dim(result_boot$t)[2]) {
    if (is.na(McpNA[i])){intervalo_confianza[i,] =rep(NA,4)} else {
      ci_McpAUC <- boot::boot.ci(result_boot, type <- type.interval, conf = level, index = i )
      p_max=length(ci_McpAUC[[4]])
      intervalo_confianza[i,]=c(result_boot$t0[i],ci_McpAUC[[4]][c(p_max-1,p_max)],sd(result_boot$t[,i]))
    }
  }
  colnames(intervalo_confianza)=c("MCp_AUC","lwr","upr","sd")
  names <- c("MCp_AUC","lwr","upr","sd")
  obj <- list(intervalo_confianza[,1],intervalo_confianza[,2],intervalo_confianza[,3],intervalo_confianza[,4])
  x <- createSE(obj, names)

  return(x)

}

```

```{r, warning='hide'}
resultsMcboot <- MCpAUCboot(genes,low.value = 0, up.value = 0.25, seed = 1234)

```


```{r, echo='hide', results='hide'}
test.MCpAUCboot <- assay(resultsMcboot)
resultMc <- t(as.data.frame(cbind(test.MCpAUCboot$MCp_AUC,test.MCpAUCboot$sd,test.MCpAUCboot$lwr,test.MCpAUCboot$upr)))
colnames(resultMc) <- c("Gene1", "Gene2", "Gene3", "Gene4", "Gene5")
rownames(resultMc) <- c("MCp_AUC","sd","lwr","upr")
```
```{r}
resultMc
```

# Information #

## Contact ##

The source code is available at **github**. For bug/error reports please refer
to ROCpAI github issues [https://github.com/juanpegarcia/ROCpAI/issues](https://github.com/juanpegarcia/ROCpAI/issues).

## License ##

The package `ROCpAI` is licensed under GPL-3.

## How to cite ##

Currently there is no literature for `ROCpAI`. Please cite the R package, the
github. This package will be updated as soon as a citation is
available.

## Session information ##

```{r sessionInfo, eval=TRUE}
sessionInfo()
```

## Bibliography ## 


