---
title: "Analisys of partial ROC curves"
author:
- name: "Manuel Franco"
  affiliation: &deio Departamento de Estadística e Investigación Operativa, Universidad de Murcia, 30100, Murcia, Spain
- name: "Juana-María Vivo"
  affiliation: *deio
- name: "Juan Pedro García Ortiz"
  affiliation: *dis
package: ROC
date: "2019-09-02"
bibliography: ../inst/REFERENCES.bib
biblio-style: apsr
link-citations: yes
abstract: >
  R package **ROC** how-to guide
output: 
  BiocStyle::html_document:
    toc_float: FALSE
vignette: >
  %\VignetteIndexEntry{Analisys of partial ROC curves}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}  
---

```{r style, include=FALSE, results='hide'}
BiocStyle::markdown()
library(golubEsets)
```

Vivo, J.-M., Franco, M. and Vicari, D. (2017). Rethinking an ROC partial area index for evaluating the classification performance at a high specificity range. Advances in Data Analysis and Classification, 12(3), pp.683–704.

# Introduction #

The **ROC** package permits to calculate the complete area under the curve ROC (AUC)
and the partial area under the curve ROC (AUCp) even if the curve ROC is non proper.
To do this the package calculate the specificty and sensibility from a logistic
model with the function **points.curve**, and calculate the area with and without
been standarized by the McClish index with the **McAUC** if the ROC curve is proper
or with the **TpAUC** if the ROC curve is non proper
# Installation #
The installation of **ROC** package is performed via Github:
```{r installation, eval=FALSE}
devtools::install_github("juanpegarcia/ROC")
```

## Prerequisites ##

The package **ROC** depends on the following Bioconductor package :
GolubEset

# Using ROC #

## data.frame with the model's information ##

The package's functions work with a data.frame with at least 2 columns. The first one
is the case's tag and the second one is the value that the model has assigned to each case

```{r, echo=FALSE, include=FALSE, results='hide'}
library(golubEsets)
library(pcaMethods)
library("rms")
library("caret")
data("Golub_Merge")

golub.expression <- Golub_Merge@assayData$exprs
golub.expression <- t(golub.expression)
golub.expression.normal = preprocessCore::normalize.quantiles(as.matrix(golub.expression))
golub.type <- Golub_Merge$ALL.AML
golub.PCA.1 <- pca(golub.expression.normal,nPcs = 1)
golub.PCA.1
golub.model.1 <- lrm(golub.type~golub.PCA.1@scores)
golub.prediction.1=predict(golub.model.1)
golub.sample<- c(1:dim(golub.expression.normal)[1])

golub.data.PCA <- cbind(golub.type, golub.prediction.1)
golub.data.PCA <- data.frame(golub.data.PCA[,1]-1,golub.data.PCA[,-1])
golub.data.PCA
```

Data.frame example

ID    | Tag | Value       | 
----- | ----| ----------- | 
case1 | 0   | -0.58347844 | 
case2 | 0   | -0.57429223 | 
case3 | 0   | -0.82971186 | 
case4 | 1   | -0.25710273 | 
case5 | 1   | -0.37002670 | 
case6 | 1   |  0.34222911 | 

## Function to calculate specifity and sensibility: Point.Curves ##

This function generate the sensibility and the specifity for each point creater between 
the lowest and highest value related to the cases once the model has been aplied. Points.curve needs 2 parameters:
xsample and ysample. The first parameter correspond to the cases tags, while the seconde parameter is the value 
that the model has generated for each cases. The function generate as much points as cases there are in the vectors.
Th points are generated through the mean between the ysample's lowest value and the next one, plus a point with the 
lowest value minus one, and another point with the highest value plus one.

```{r, echo=FALSE}
points_curve<-function(xsample, ysample){
  points<-NULL; prepoint<-NULL; fpr.point<-NULL; sen.point<-NULL; xy<-NULL
  points<-sort(ysample)
  points<-append(points[-length(points)]+diff(points)/2, min(points)-1, 0)
  points<-append(points, max(ysample)+1, length(points))
  for (point in points) {
    pre.point<-(ysample>point)*1
    fpr.point[which(points == point)]<-sum((pre.point == 1)*(xsample == 0))/sum(xsample == 0)
    sen.point[which(points == point)]<-sum((pre.point == 1)*(xsample == 1))/sum(xsample == 1)
  }
  if (is.unsorted(sen.point)) {
    sen.point<-rev(sen.point)
    fpr.point<-rev(fpr.point)}
  xy<-cbind(fpr.point, sen.point)
  return(xy)
}
```

```{r, echo=FALSE}

points <- points_curve(golub.data.PCA[,1],golub.data.PCA[,2])


```




## MpAUC ##

Function to calculate the proper ROC's area under the partial curve with the McClish index

This function calculates the AUCp introduced through the parameters. This function has four parameters:
two mandatories (dataset and datasample) and two optionals (low limit and up limit.). 
Dataset is a dataframe object generated by the model, this must be formed for two columns, the first one 
belong to the tags and the second to the values generated by the model.
The datasample parameter is a vector in which is indicated the dataset's cases that are going to be
tested.
The limits parameters are two numeric values between 0 and 1. If these parameters are null the function
take 0 and 1 as low.limit and up.limit respectivly. 
The function returns and object with four elements: AUCp without standarization, AUCp standarized, sensibilities 
and specifities.
Notice that if the AUCp is under the diagonal line the AUCp standarized will be NA.


```{r, echo=FALSE}
   McpAUC <- function(bsdataset, bsdatasample,  low.value=NULL, up.value=NULL) {
    ## Variables and initial values for each sample<-ROC curve
    dataset.boot<-bsdataset[bsdatasample, ]
    setsample<-dataset.boot[,1]
    datasample<-dataset.boot[, 2]

    fpr.roc<-points_curve(setsample, datasample)[, 1] #fpr es especificidad VP/VP+FN
    sen.roc<-points_curve(setsample, datasample)[, 2] #sen es sensibilidad VN/VN+FR
    ### ORDER fpr & sen from 0 to 1
    if (is.unsorted(sen.roc)) {
      sen.roc<-rev(sen.roc)
      fpr.roc<-rev(fpr.roc)}
    ## Variables and initial values for the partial area of each ROC curve
    fpr.proc<-NULL; sen.proc<-NULL; proper.proc<-NULL; plr.proc<-NULL; plr.proc.bounded<-NULL
    i.low<-NULL; i.up<-NULL; j.low<-NULL; j.up<-NULL; upper.limit <- NULL; lower.limit <- NULL
    Ap.roc<-NULL; Mc.pAUC.min.roc<-NULL; TpAUC.roc<-NULL; TpAUC.min.roc<-NULL; TpAUC.max.roc<-NULL
    ### PARTIAL ROC curve (fpr.proc; sen.proc) on [lower.fp <= e <= upper.fp]

    if (!is.null(up.value)){upper.limit <- up.value}else{upper.limit <- fpr.roc[length(fpr.roc)]}
    if (!is.null(low.value)){lower.limit <- low.value}else{lower.limit <- fpr.roc[1]}

    i.low<-min(which(fpr.roc >= lower.limit))  
    j.low<-max(i.low-1, 1)
    i.up<-max(which(fpr.roc <= upper.limit)) 
    j.up<-min(1+i.up, length(fpr.roc))
    fpr.proc<-fpr.roc[i.low:i.up]
    sen.proc<-sen.roc[i.low:i.up]
    if (fpr.roc[i.low] > lower.limit) {
      fpr.proc<-append(fpr.proc, lower.limit, 0)
      sen.proc<-append(sen.proc, sen.roc[j.low]+(sen.roc[i.low]-sen.roc[j.low])*(fpr.proc[1]-fpr.roc[j.low])/(fpr.roc[i.low]-fpr.roc[j.low]), 0)}
    if (fpr.roc[i.up] < upper.limit) {
      fpr.proc<-append(fpr.proc, upper.limit, length(fpr.proc))
      sen.proc<-append(sen.proc, sen.roc[j.up]-(sen.roc[j.up]-sen.roc[i.up])*(fpr.roc[j.up]-fpr.proc[length(fpr.proc)])/(fpr.roc[j.up]-fpr.roc[i.up]), length(sen.proc))}
    #fpr.proc es la especificidad
    #sen.proc es la sensibilidad
    Ap.roc<-sum(diff(fpr.proc)*apply(cbind(sen.proc[-1], sen.proc[-length(sen.proc)]), 1, mean))

  ### TYPE OF PORTION ROC curve on [lower.fp <= e <= upper.fp]
  if (all(sen.proc >= fpr.proc)) {proper.proc<-TRUE} else {proper.proc<-FALSE}
  #warning("Improper ROC curve on partial region: min.pauc<-(e2^2-e1^2)/2>pAUC")
  ### BOUNDS FOR PARTIAL AREA INDEXES: MIN & MAX boundaries for Mc.pAUC index
  Mc.pAUC.max.roc<-sum(diff(fpr.proc))
  if (Mc.pAUC.max.roc < Ap.roc) {warning("Impossible: Nonincreasing partial ROC curve")}
  Mc.pAUC.min.roc<-sum(diff(fpr.proc^2))/2
  if (proper.proc) {
    if (Mc.pAUC.max.roc == Ap.roc) {Mc.pAUC.roc<-1} else {
      if (Mc.pAUC.max.roc == Mc.pAUC.min.roc) {Mc.pAUC.roc<-1
      warning("Mc.pAUC index: Constant partial ROC curve")} else {
        Mc.pAUC.roc<-(1+((Ap.roc-Mc.pAUC.min.roc)/(Mc.pAUC.max.roc-Mc.pAUC.min.roc)))/2}
    }} else {Mc.pAUC.roc<-NA}
  #warning("Improper partial ROC curve: McClish's pAUC index is not well defined")
  objet <- list(Area.Parcial.Estandarizada =Mc.pAUC.roc ,Area.Parcial.Sin.Estandarizar=Ap.roc, Sensitivities =sen.proc, Specifities.Complementary = fpr.proc)
  return(objet)

}

```


```{r, echo=TRUE}
McpAUC.GOLUB <- McpAUC(golub.data.PCA,golub.sample,0.8,1)
plot(McpAUC.GOLUB$Sensitivities~McpAUC.GOLUB$Specifities.Complementary,ylab="SENSIBILITY",xlab="1-SPECIFITY", type="l",main="PARTIAL ROC (0.8,1)")
abline(a=c(0,1),lwd=1)
McpAUC.GOLUB
```

## TpAUC ##

Function to calculate proper and non proper ROC's area under the partial curve with the McClish index

This function clasifies the ROC curve as valid or non valid using the specificity and sensibility that the 
function Points.curve has created. If is valid the function clasifies it as proper or non proper.
Once is clasified, the function calculates the AUCp. A invalid ROC curve is once that is not growing. While and non proper is one that cross the diagonal line. 
This function has four parameters:
two mandatories (dataset and datasample) and two optionals (low limit and up limit.). 
Dataset is a dataframe object generated by the model, this must be formed for two columns, the first one 
belong to the tags and the second to the values generated by the model.
The datasample parameter is a vector in which is indicated the dataset's cases that are going to be
tested.
The limits parameters are two numeric values between 0 and 1. If these parameters are null the function
take 0 and 1 as low.limit and up.limit respectivly. 
The function returns and object with four elements: AUCp without standarization, AUCp standarized, sensibilities 
and specifities.

```{r, echo=FALSE}
TpAUC <- function(bsdataset, bsdatasample,  low.value=NULL, up.value=NULL) {
  ## Variables and initial values for each sample<-ROC curve
  dataset.boot<-bsdataset[bsdatasample, ]
  setsample<-dataset.boot[,1]
  datasample<-dataset.boot[, 2]

  fpr.roc<-points_curve(setsample, datasample)[, 1] #fpr es especificidad VP/VP+FN
  sen.roc<-points_curve(setsample, datasample)[, 2] #sen es sensibilidad VN/VN+FR
  ### ORDER fpr & sen from 0 to 1
  if (is.unsorted(sen.roc)) {
    sen.roc<-rev(sen.roc)
    fpr.roc<-rev(fpr.roc)}
  ## Variables and initial values for the partial area of each ROC curve
  fpr.proc<-NULL; sen.proc<-NULL; proper.proc<-NULL; plr.proc<-NULL; plr.proc.bounded<-NULL
  i.low<-NULL; i.up<-NULL; j.low<-NULL; j.up<-NULL; upper.limit <- NULL; lower.limit <- NULL
  Ap.roc<-NULL; Mc.pAUC.min.roc<-NULL; TpAUC.roc<-NULL; TpAUC.min.roc<-NULL; TpAUC.max.roc<-NULL
  ### PARTIAL ROC curve (fpr.proc; sen.proc) on [lower.fp <= e <= upper.fp]

  if (!is.null(up.value)){upper.limit <- up.value}else{upper.limit <- fpr.roc[length(fpr.roc)]}
  if (!is.null(low.value)){lower.limit <- low.value}else{lower.limit <- fpr.roc[1]}

  i.low<-min(which(fpr.roc >= lower.limit)) 
  j.low<-max(i.low-1, 1)
  i.up<-max(which(fpr.roc <= upper.limit)) 
  j.up<-min(1+i.up, length(fpr.roc))
  fpr.proc<-fpr.roc[i.low:i.up]
  sen.proc<-sen.roc[i.low:i.up]
  if (fpr.roc[i.low] > lower.limit) {
    fpr.proc<-append(fpr.proc, lower.limit, 0)
    sen.proc<-append(sen.proc, sen.roc[j.low]+(sen.roc[i.low]-sen.roc[j.low])*(fpr.proc[1]-fpr.roc[j.low])/(fpr.roc[i.low]-fpr.roc[j.low]), 0)}
  if (fpr.roc[i.up] < upper.limit) {
    fpr.proc<-append(fpr.proc, upper.limit, length(fpr.proc))
    sen.proc<-append(sen.proc, sen.roc[j.up]-(sen.roc[j.up]-sen.roc[i.up])*(fpr.roc[j.up]-fpr.proc[length(fpr.proc)])/(fpr.roc[j.up]-fpr.roc[i.up]), length(sen.proc))}
  #fpr.proc es la especificidad
  #sen.proc es la sensibilidad
  Ap.roc<-sum(diff(fpr.proc)*apply(cbind(sen.proc[-1], sen.proc[-length(sen.proc)]), 1, mean))

  ### TYPE OF PORTION ROC curve on [lower.fp <= e <= upper.fp]
  if (all(sen.proc>=fpr.proc)) {proper.proc<-TRUE} else {proper.proc<-FALSE}
  #warning("Improper ROC curve on partial region: min.pauc<-(e2^2-e1^2)/2>pAUC")
  plr.proc<-(sen.proc-sen.proc[1])/(fpr.proc-fpr.proc[1])
  plr.proc<-plr.proc[is.finite(plr.proc)]
  if (all(plr.proc>=plr.proc[length(plr.proc)])) {plr.proc.bounded<-TRUE} else {plr.proc.bounded<-FALSE}
  #warning("PORTION ROC curve over partial plr")
  ### BOUNDS FOR PARTIAL AREA INDEXES: MIN & MAX boundaries for TpAUC index
  Mc.pAUC.min.roc<-sum(diff(fpr.proc^2))/2
  TpAUC.max.roc<-sum(diff(fpr.proc))*max(sen.proc)

  if (TpAUC.max.roc < Ap.roc) {warning("Impossible: Nonincreasing partial ROC curve")
    TpAUC.max.roc<-sum(diff(fpr.proc))}
  if (plr.proc.bounded) {TpAUC.min.roc<-sum(diff(fpr.proc))*mean(c(min(sen.proc), max(sen.proc)))
  } else {if (proper.proc) {
    TpAUC.min.roc<-max(sum(diff(fpr.proc))*min(sen.proc), Mc.pAUC.min.roc)} else {
      TpAUC.min.roc<-sum(diff(fpr.proc))*min(sen.proc)}}

  if (TpAUC.min.roc > Ap.roc) {warning("Impossible: Improper & nonincreasing partial ROC curve")}
  if (TpAUC.max.roc == Ap.roc) {TpAUC.roc<-1} else {
    if (TpAUC.max.roc == TpAUC.min.roc) {#max=min => max=Ap => this case is impossible
      TpAUC.roc<-1
      warning("TpAUC index: Constant partial ROC curve")} else {
        TpAUC.roc<-(1+((Ap.roc-TpAUC.min.roc)/(TpAUC.max.roc-TpAUC.min.roc)))/2}} 


  object <- list(Area.Parcial.Estandarizada =TpAUC.roc ,Area.Parcial.Sin.Estandarizar=Ap.roc, Sensitivities =sen.proc, Specifities.Complementary = fpr.proc)
  return(object)
}
```

```{r}
TpAUC.GOLUB <- TpAUC(golub.data.PCA,golub.sample,0.8,1)
plot(TpAUC.GOLUB$Sensitivities~TpAUC.GOLUB$Specifities.Complementary,ylab="SENSIBILITY",xlab="1-SPECIFITY", type="l",main="PARTIAL ROC (0.8,1)")
abline(a=c(0,1),lwd=1)
TpAUC.GOLUB
```

# Information #

## Contact ##

The source code is available at **github**. For bug/error reports please refer
to evaluomeR github issues [https://github.com/juanpegarcia/ROC/issues](https://github.com/juanpegarcia/ROC/issues).

## License ##

The package 'ROC' is licensed under GPL-3.

## How to cite ##

Currently there is no literature for ROC. Please cite the R package, the
github or the website. This package will be updated as soon as a citation is
available.

## Additional information ##


## Session information ##

```{r sessionInfo, eval=TRUE}
sessionInfo()
```

## Bibliography ## 
