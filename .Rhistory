#' @param plot ROC plot
#' @param low.value lower false positive rate value that the function will use to calculate the pAUC
#' @param up.value upper false positive rate value that the function will use to calculate the pAUC
#' @param selection  vector that will only be used if the parameter "dataset" is a RangedSummarizedExperiment object.
#' This parameter is used to select the variables that will be analysed
#' @param variable in case that dataset is a  SummarizedExperiment, indicate the Gold Standard
#' @return RangedSummarizedExperiment object with the pAUC and the TpAUC scores,and the TPR and FPR values for each ROC curve generated
#' @export TpAUC.roc
#' @examples
#'library(fission)
#'data("fission")
#'resultsT <- TpAUC(fission, low.value = 0, up.value = 0.25, plot = TRUE, selection = c("SPNCRNA.1080","SPAC186.08c"), varidable="strain")
TpAUC <- function(dataset,  low.value = NULL, up.value = NULL, plot = FALSE, selection = NULL, variable=NULL ) {
St_pAUC <-NULL; pAUC <- NULL; sensitivity <- NULL; FPR <- NULL;
fpr.proc<-NULL; sen.proc<-NULL;  up.limit <- NULL; low.limit <- NULL;
Ap.roc<-NULL;   object <- NULL;  par <- NULL; legend <- NULL; abline <- NULL;
## Variables and initial values for each sample<-ROC curve
par(new=FALSE)
name.variable <- colnames(dataset)
if (class(dataset)=="RangedSummarizedExperiment") {
strain <- dataset@colData@listData
strain <- strain[variable][[1]]
dataset <- as.data.frame(SummarizedExperiment::assay(dataset))
dataset <- scale(t(as.matrix(dataset[selection,])), center=TRUE, scale = TRUE)
name.variable <- colnames(dataset)
dataset <- as.data.frame(cbind(strain,dataset))
name.variable <- colnames(dataset)[-2]
}  else {  dataset <- as.data.frame(dataset)
}
dimension <- dim(dataset)
if(dimension[2]<2) {stop("database has to have at least 2 colums")}
for (i in 2:dimension[2]) {
dataset_temporal <- cbind(dataset[,1],dataset[i])
sen.roc<- points_curve(dataset_temporal[,1],dataset_temporal[,2])[,2]
fpr.roc<- points_curve(dataset_temporal[,1],dataset_temporal[,2])[,1]
## Variables and initial values for the partial area of each ROC curve
### PARTIAL ROC curve (fpr.proc; sen.proc) on [lower.fp <= e <= upper.fp]
if (!is.null(up.value)){up.limit <- up.value}else{up.limit <- 1}
if (!is.null(low.value)){low.limit <- low.value}else{low.limit <- 0}
fpr.proc <- portion_ROC(up.limit, low.limit, fpr.roc,sen.roc)[,1]
sen.proc <- portion_ROC(up.limit, low.limit, fpr.roc,sen.roc)[,2]
St_pAUC[[i-1]] <- TpA(fpr.proc,sen.proc)
pAUC[[i-1]] <- as.vector(pA(fpr.proc,sen.proc))
sensitivity[[i-1]] <-as.vector(sen.proc)
FPR[[i-1]] <- as.vector(fpr.proc)
if (isTRUE(plot)) {plot(sen.roc~fpr.roc, type="l", col=i, ylab="TPR", xlab="FPR")
legend(x= "bottomright",legend = name.variable[2:i], fill = 2:i, cex = 0.8)
abline(a=c(0,1),lwd=1, col="grey")
abline(v=low.value,col="black")
abline(v=up.value,col="black")
par(new=TRUE)
}
}
object <- list(St_pAUC, pAUC, sensitivity, FPR)
names <- c("St_pAUC","pAUC", "Sensitivity", "FPR")
se <- createSE(object, names)
return(se)
}
TpAUC.fission.genes <- TpAUC(fission, plot=TRUE, low.value = 0, up.value = 0.15,
selection = c("SPNCRNA.1080","SPAC186.08c","SPNCRNA.1420","SPCC70.08c"),
variable = "strain")
#' @title Tigher partial area under the ROC curve
#' @description It standarizes the partial area under the ROC curve by the tigher index
#' @param dataset Dataframe of the complete information of the samples
#' @param low.value inferior limit
#' @param up.value inferior limit
#' @param plot ROC plot
#' @param low.value lower false positive rate value that the function will use to calculate the pAUC
#' @param up.value upper false positive rate value that the function will use to calculate the pAUC
#' @param selection  vector that will only be used if the parameter "dataset" is a RangedSummarizedExperiment object.
#' This parameter is used to select the variables that will be analysed
#' @param variable in case that dataset is a  SummarizedExperiment, indicate the Gold Standard
#' @return RangedSummarizedExperiment object with the pAUC and the TpAUC scores,and the TPR and FPR values for each ROC curve generated
#' @export TpAUC.roc
#' @examples
#'library(fission)
#'data("fission")
#'resultsT <- TpAUC(fission, low.value = 0, up.value = 0.25, plot = TRUE, selection = c("SPNCRNA.1080","SPAC186.08c"), varidable="strain")
TpAUC <- function(dataset,  low.value = NULL, up.value = NULL, plot = FALSE, selection = NULL, variable=NULL ) {
St_pAUC <-NULL; pAUC <- NULL; sensitivity <- NULL; FPR <- NULL;
fpr.proc<-NULL; sen.proc<-NULL;  up.limit <- NULL; low.limit <- NULL;
Ap.roc<-NULL;   object <- NULL;  par <- NULL; legend <- NULL; abline <- NULL;
## Variables and initial values for each sample<-ROC curve
par(new=FALSE)
name.variable <- colnames(dataset)
if (class(dataset)=="RangedSummarizedExperiment") {
strain <- dataset@colData@listData
strain <- strain[variable][[1]]
dataset <- as.data.frame(SummarizedExperiment::assay(dataset))
dataset <- scale(t(as.matrix(dataset[selection,])), center=TRUE, scale = TRUE)
name.variable <- colnames(dataset)
dataset <- as.data.frame(cbind(strain,dataset))
name.variable <- colnames(dataset)[-2]
print(name.variable)
}  else {  dataset <- as.data.frame(dataset)
}
dimension <- dim(dataset)
if(dimension[2]<2) {stop("database has to have at least 2 colums")}
for (i in 2:dimension[2]) {
dataset_temporal <- cbind(dataset[,1],dataset[i])
sen.roc<- points_curve(dataset_temporal[,1],dataset_temporal[,2])[,2]
fpr.roc<- points_curve(dataset_temporal[,1],dataset_temporal[,2])[,1]
## Variables and initial values for the partial area of each ROC curve
### PARTIAL ROC curve (fpr.proc; sen.proc) on [lower.fp <= e <= upper.fp]
if (!is.null(up.value)){up.limit <- up.value}else{up.limit <- 1}
if (!is.null(low.value)){low.limit <- low.value}else{low.limit <- 0}
fpr.proc <- portion_ROC(up.limit, low.limit, fpr.roc,sen.roc)[,1]
sen.proc <- portion_ROC(up.limit, low.limit, fpr.roc,sen.roc)[,2]
St_pAUC[[i-1]] <- TpA(fpr.proc,sen.proc)
pAUC[[i-1]] <- as.vector(pA(fpr.proc,sen.proc))
sensitivity[[i-1]] <-as.vector(sen.proc)
FPR[[i-1]] <- as.vector(fpr.proc)
if (isTRUE(plot)) {plot(sen.roc~fpr.roc, type="l", col=i, ylab="TPR", xlab="FPR")
legend(x= "bottomright",legend = name.variable[2:i], fill = 2:i, cex = 0.8)
abline(a=c(0,1),lwd=1, col="grey")
abline(v=low.value,col="black")
abline(v=up.value,col="black")
par(new=TRUE)
}
}
object <- list(St_pAUC, pAUC, sensitivity, FPR)
names <- c("St_pAUC","pAUC", "Sensitivity", "FPR")
se <- createSE(object, names)
return(se)
}
TpAUC.fission.genes <- TpAUC(fission, plot=TRUE, low.value = 0, up.value = 0.15,
selection = c("SPNCRNA.1080","SPAC186.08c","SPNCRNA.1420","SPCC70.08c"),
variable = "strain")
#' @title Tigher partial area under the ROC curve
#' @description It standarizes the partial area under the ROC curve by the tigher index
#' @param dataset Dataframe of the complete information of the samples
#' @param low.value inferior limit
#' @param up.value inferior limit
#' @param plot ROC plot
#' @param low.value lower false positive rate value that the function will use to calculate the pAUC
#' @param up.value upper false positive rate value that the function will use to calculate the pAUC
#' @param selection  vector that will only be used if the parameter "dataset" is a RangedSummarizedExperiment object.
#' This parameter is used to select the variables that will be analysed
#' @param variable in case that dataset is a  SummarizedExperiment, indicate the Gold Standard
#' @return RangedSummarizedExperiment object with the pAUC and the TpAUC scores,and the TPR and FPR values for each ROC curve generated
#' @export TpAUC.roc
#' @examples
#'library(fission)
#'data("fission")
#'resultsT <- TpAUC(fission, low.value = 0, up.value = 0.25, plot = TRUE, selection = c("SPNCRNA.1080","SPAC186.08c"), varidable="strain")
TpAUC <- function(dataset,  low.value = NULL, up.value = NULL, plot = FALSE, selection = NULL, variable=NULL ) {
St_pAUC <-NULL; pAUC <- NULL; sensitivity <- NULL; FPR <- NULL;
fpr.proc<-NULL; sen.proc<-NULL;  up.limit <- NULL; low.limit <- NULL;
Ap.roc<-NULL;   object <- NULL;  par <- NULL; legend <- NULL; abline <- NULL;
## Variables and initial values for each sample<-ROC curve
par(new=FALSE)
name.variable <- colnames(dataset)
if (class(dataset)=="RangedSummarizedExperiment") {
strain <- dataset@colData@listData
strain <- strain[variable][[1]]
dataset <- as.data.frame(SummarizedExperiment::assay(dataset))
dataset <- scale(t(as.matrix(dataset[selection,])), center=TRUE, scale = TRUE)
name.variable <- colnames(dataset)
dataset <- as.data.frame(cbind(strain,dataset))
name.variable <- colnames(dataset)
print(name.variable)
}  else {  dataset <- as.data.frame(dataset)
}
dimension <- dim(dataset)
if(dimension[2]<2) {stop("database has to have at least 2 colums")}
for (i in 2:dimension[2]) {
dataset_temporal <- cbind(dataset[,1],dataset[i])
sen.roc<- points_curve(dataset_temporal[,1],dataset_temporal[,2])[,2]
fpr.roc<- points_curve(dataset_temporal[,1],dataset_temporal[,2])[,1]
## Variables and initial values for the partial area of each ROC curve
### PARTIAL ROC curve (fpr.proc; sen.proc) on [lower.fp <= e <= upper.fp]
if (!is.null(up.value)){up.limit <- up.value}else{up.limit <- 1}
if (!is.null(low.value)){low.limit <- low.value}else{low.limit <- 0}
fpr.proc <- portion_ROC(up.limit, low.limit, fpr.roc,sen.roc)[,1]
sen.proc <- portion_ROC(up.limit, low.limit, fpr.roc,sen.roc)[,2]
St_pAUC[[i-1]] <- TpA(fpr.proc,sen.proc)
pAUC[[i-1]] <- as.vector(pA(fpr.proc,sen.proc))
sensitivity[[i-1]] <-as.vector(sen.proc)
FPR[[i-1]] <- as.vector(fpr.proc)
if (isTRUE(plot)) {plot(sen.roc~fpr.roc, type="l", col=i, ylab="TPR", xlab="FPR")
legend(x= "bottomright",legend = name.variable[2:i], fill = 2:i, cex = 0.8)
abline(a=c(0,1),lwd=1, col="grey")
abline(v=low.value,col="black")
abline(v=up.value,col="black")
par(new=TRUE)
}
}
object <- list(St_pAUC, pAUC, sensitivity, FPR)
names <- c("St_pAUC","pAUC", "Sensitivity", "FPR")
se <- createSE(object, names)
return(se)
}
TpAUC.fission.genes <- TpAUC(fission, plot=TRUE, low.value = 0, up.value = 0.15,
selection = c("SPNCRNA.1080","SPAC186.08c","SPNCRNA.1420","SPCC70.08c"),
variable = "strain")
par(new=FALSE)
title("pCurve - Fission dataset")
xx <- TpAUCboot(fission,low.value = 0, up.value = 0.2, seed = 1234, selection=c("SPNCRNA.1080","SPAC186.08c","SPNCRNA.1420","SPCC70.08c"), variable="strain" )
xx <- TpAUCboot(fission,low.value = 0, up.value = 0.2, seed = 1234, selection=c("SPNCRNA.1080","SPAC186.08c","SPNCRNA.1420","SPCC70.08c"), variable="strain" )
xxx <- MCpAUCboot(fission,low.value = 0, up.value =0.2, seed=NULL, selection=c("SPNCRNA.1080","SPAC186.08c","SPNCRNA.1420","SPCC70.08c"), variable="strain")
#' @title TpAUCboot
#' @description Calculates the confidence interval using a boot analysis
#' @param dataset dataframe or RangedSummarizedExperiment objetc
#' @param r number of iterations.
#' @param type.interval String that represent the type of intervals required.
#' The value should be any subset of the values c("norm","basic", "stud", "perc", "bca")
#' or simply "all" which will compute all five types of intervals.
#' @param seed Seed
#' @param low.value lower false positive rate value that the function will use to calculate the pAUC
#' @param up.value upper false positive rate value that the function will use to calculate the pAUC
#' @param selection  vector that will only be used if the parameter "dataset" is a RangedSummarizedExperiment object.
#' This parameter is used to select the variables that will be analysed
#' @param level confidence level
#' @param variable in case that dataset is a  SummarizedExperiment, indicate the Gold Standard
#' @return SummarizedExperiment object with the Tp_AUC, the standard desviation, and the lower and upper limits of the confidence interval
#' @export TpAUCboot
#' @import boot
#' @examples
#'library(fission)
#'data("fission")
#'resultstboot<- TpAUCboot(fission,low.value = 0, up.value = 0.25, seed = 1234, selection = c("SPNCRNA.1080","SPAC186.08c"), varidable="strain")
TpAUCboot <- function(dataset,  low.value = NULL, up.value = NULL,
r=50, seed=NULL, level = 0.95, type.interval="perc", selection = NULL, variable=NULL) {
ci_TpAUC <- NULL; CpA=NULL;ci_MCpAUC <- NULL; sd <- NULL; par <- NULL; legend <- NULL; abline <- NULL;
if (class(dataset)=="RangedSummarizedExperiment") {
strain <- dataset@colData@listData
strain <- strain[variable][[1]]
dataset <- as.data.frame(SummarizedExperiment::assay(dataset))
dataset <- scale(t(as.matrix(dataset[selection,])), center=TRUE, scale = TRUE)
name.variable <- colnames(dataset)
dataset <- as.data.frame(cbind(strain,dataset))
}  else {  dataset <- as.data.frame(dataset)  }
if(dim(dataset)[2]<2) {stop("database has to have at least 2 colums")}
if (!is.null(up.value)){
up.limit <- up.value
}else{
up.limit <- 1
}
if (!is.null(low.value)){
low.limit <- low.value
}else{
low.limit <- 0
}
if(is.null(seed)){
old.seed <- .Random.seed
on.exit({.Random.seed <- old.seed})
}
result_boot <- boot::boot(dataset, statistic = fbootT, R=r, low.limit = low.limit, up.limit =up.limit)
intervalo_confianza <- matrix(0,nrow=dim(result_boot$t)[2],ncol=4)
for (i in 1:dim(result_boot$t)[2]) {
ci_TpAUC <- boot::boot.ci(result_boot, type <- type.interval, conf = level, index = i )
p_max=length(ci_TpAUC[[4]])
intervalo_confianza[i,]=c(result_boot$t0[i],ci_TpAUC[[4]][c(p_max-1,p_max)],sd(result_boot$t[,i]))
}
colnames(intervalo_confianza)=c("Tp_AUC","lwr","upr","sd")
names <- c("Tp_AUC","lwr","upr","sd")
obj <- list(intervalo_confianza[,1],intervalo_confianza[,2],intervalo_confianza[,3],intervalo_confianza[,4])
x <- createSE(obj, names)
return(x)
}
xx <- TpAUCboot(fission,low.value = 0, up.value = 0.2, seed = 1234, selection=c("SPNCRNA.1080","SPAC186.08c","SPNCRNA.1420","SPCC70.08c"), variable="strain" )
x <- matrix(c(xx$Tp_AUC,xx$lwr,xx$upr),ncol = 4,nrow = 3)
xx <- TpAUCboot(fission,low.value = 0, up.value = 0.2, seed = 1234, selection=c("SPNCRNA.1080","SPAC186.08c","SPNCRNA.1420","SPCC70.08c"), variable="strain" )
xx
xx <- assays(xx)
x <- matrix(c(xx$Tp_AUC,xx$lwr,xx$upr),ncol = 4,nrow = 3)
xx
xx <- assay(xx)
xx <- TpAUCboot(fission,low.value = 0, up.value = 0.2, seed = 1234, selection=c("SPNCRNA.1080","SPAC186.08c","SPNCRNA.1420","SPCC70.08c"), variable="strain" )
xx <- assay(xx)
x <- matrix(c(xx$Tp_AUC,xx$lwr,xx$upr),ncol = 4,nrow = 3)
colnames(x) <- c("SPNCRNA.1080","SPAC186.08c","SPNCRNA.1420","SPCC70.08c" )
boxplot(x, title("Intervalo de confianza"))
par(new=FALSE)
x <- matrix(c(xx$Tp_AUC,xx$lwr,xx$upr),ncol = 4,nrow = 3)
colnames(x) <- c("SPNCRNA.1080","SPAC186.08c","SPNCRNA.1420","SPCC70.08c" )
boxplot(x)
boxplot(x, title("Intervalo de confianza"))
#' @title TpAUCboot
#' @description Calculates the confidence interval using a boot analysis
#' @param dataset dataframe or RangedSummarizedExperiment objetc
#' @param r number of iterations.
#' @param type.interval String that represent the type of intervals required.
#' The value should be any subset of the values c("norm","basic", "stud", "perc", "bca")
#' or simply "all" which will compute all five types of intervals.
#' @param seed Seed
#' @param low.value lower false positive rate value that the function will use to calculate the pAUC
#' @param up.value upper false positive rate value that the function will use to calculate the pAUC
#' @param selection  vector that will only be used if the parameter "dataset" is a RangedSummarizedExperiment object.
#' This parameter is used to select the variables that will be analysed
#' @param level confidence level
#' @param variable in case that dataset is a  SummarizedExperiment, indicate the Gold Standard
#' @return SummarizedExperiment object with the Tp_AUC, the standard desviation, and the lower and upper limits of the confidence interval
#' @export TpAUCboot
#' @import boot
#' @examples
#'library(fission)
#'data("fission")
#'resultstboot<- TpAUCboot(fission,low.value = 0, up.value = 0.25, seed = 1234, selection = c("SPNCRNA.1080","SPAC186.08c"), varidable="strain")
TpAUCboot <- function(dataset,  low.value = NULL, up.value = NULL,
r=50, seed=NULL, level = 0.95, type.interval="perc", selection = NULL, variable=NULL) {
ci_TpAUC <- NULL; CpA=NULL;ci_MCpAUC <- NULL; sd <- NULL; par <- NULL; legend <- NULL; abline <- NULL;
if (class(dataset)=="RangedSummarizedExperiment") {
strain <- dataset@colData@listData
strain <- strain[variable][[1]]
dataset <- as.data.frame(SummarizedExperiment::assay(dataset))
dataset <- scale(t(as.matrix(dataset[selection,])), center=TRUE, scale = TRUE)
name.variable <- colnames(dataset)
dataset <- as.data.frame(cbind(strain,dataset))
}  else {  dataset <- as.data.frame(dataset)  }
if(dim(dataset)[2]<2) {stop("database has to have at least 2 colums")}
if (!is.null(up.value)){
up.limit <- up.value
}else{
up.limit <- 1
}
if (!is.null(low.value)){
low.limit <- low.value
}else{
low.limit <- 0
}
if(is.null(seed)){
old.seed <- .Random.seed
on.exit({.Random.seed <- old.seed})
}
result_boot <- boot::boot(dataset, statistic = fbootT, R=r, low.limit = low.limit, up.limit =up.limit)
intervalo_confianza <- matrix(0,nrow=dim(result_boot$t)[2],ncol=4)
for (i in 1:dim(result_boot$t)[2]) {
ci_TpAUC <- boot::boot.ci(result_boot, type <- type.interval, conf = level, index = i )
p_max=length(ci_TpAUC[[4]])
intervalo_confianza[i,]=c(result_boot$t0[i],ci_TpAUC[[4]][c(p_max-1,p_max)],sd(result_boot$t[,i]))
}
colnames(intervalo_confianza)=c("Tp_AUC","lwr","upr","sd")
names <- c("Tp_AUC","lwr","upr","sd")
obj <- list(intervalo_confianza[,1],intervalo_confianza[,2],intervalo_confianza[,3],intervalo_confianza[,4])
x <- createSE(obj, names)
return(x)
}
#to clasificate the portion of the ROC curve
#portion ROC over a fixed interval
portion_ROC <- function(up.limit, low.limit, fpr.roc,sen.roc){
i.low<-min(which(fpr.roc >= low.limit))
j.low<-max(i.low-1, 1)
i.up<-max(which(fpr.roc <= up.limit))
j.up<-min(1+i.up, length(fpr.roc))
fpr.proc<-fpr.roc[i.low:i.up]
sen.proc<-sen.roc[i.low:i.up]
if (fpr.roc[i.low] > low.limit) {
fpr.proc<-append(fpr.proc, low.limit, 0)
sen.proc<-append(sen.proc, sen.roc[j.low]+(sen.roc[i.low]-sen.roc[j.low])*(fpr.proc[1]-fpr.roc[j.low])/(fpr.roc[i.low]-fpr.roc[j.low]), 0)}
if (fpr.roc[i.up] < up.limit) {
fpr.proc<-append(fpr.proc, up.limit, length(fpr.proc))
sen.proc<-append(sen.proc, sen.roc[j.up]-(sen.roc[j.up]-sen.roc[i.up])*(fpr.roc[j.up]-fpr.proc[length(fpr.proc)])/(fpr.roc[j.up]-fpr.roc[i.up]), length(sen.proc))}
return(cbind(fpr.proc, sen.proc))
}
classification_Tp <- function(fpr.proc,sen.proc){
if (all(sen.proc>=fpr.proc)) {
proper.proc<-TRUE} else {proper.proc<-FALSE}
plr.proc<-(sen.proc-sen.proc[1])/(fpr.proc-fpr.proc[1])
plr.proc<-plr.proc[is.finite(plr.proc)]
if (all(plr.proc>=plr.proc[length(plr.proc)])) {
plr.proc.bounded<-TRUE} else {plr.proc.bounded<-FALSE}
classification <- c(plr.proc.bounded,proper.proc)
return(classification)
}
#tighter partial area under a portion
TpA <- function(fpr.proc, sen.proc){
pA.roc <- pA(fpr.proc, sen.proc)
type_roc <- classification_Tp(fpr.proc, sen.proc)
min.pAUC<-sum(diff(fpr.proc^2))/2
max.pAUC<-sum(diff(fpr.proc))
TpAUC.max.roc<-max.pAUC*max(sen.proc)
if (min(sen.proc) == max(sen.proc) ) {
TpAUC.min.roc =0} else {
if (type_roc[1]) {
TpAUC.min.roc<-sum(diff(fpr.proc))*mean(c(min(sen.proc), max(sen.proc)))
} else {
if (type_roc[2]) {
TpAUC.min.roc<-max(max.pAUC*min(sen.proc), min.pAUC)
} else {TpAUC.min.roc<-max.pAUC*min(sen.proc)}
}
}
if (min(fpr.proc) == max(fpr.proc) ) { TpAUC.max.roc = 1}
if (max(sen.proc)!=0 )
{TpA.roc<-(1+((pA.roc-TpAUC.min.roc)/(TpAUC.max.roc-TpAUC.min.roc)))/2} else {TpA.roc=0}
return(TpA.roc)
}
#Calculate the partial area under a portion
pA <- function(fpr.proc,sen.proc){
aux <- sum(diff(fpr.proc)*
apply(cbind(sen.proc[-1],
sen.proc[-length(sen.proc)]), 1, mean))
return(aux)
}
#McClish partial area under a portion
MCpA <- function(sen.proc,fpr.proc){
pA.roc <- pA(fpr.proc, sen.proc)
type_roc <- classification_Tp(fpr.proc, sen.proc)
max.pAUC <- sum(diff(fpr.proc))
min.pAUC <- sum(diff(fpr.proc^2))/2
if (type_roc[2]) {
if (min(fpr.proc) == max(fpr.proc) ) { max.pAUC = 1}
MCpA.roc<-(1+((pA.roc-min.pAUC)/(max.pAUC-min.pAUC)))/2
} else {
MCpA.roc<-NA}
#warning("Improper partial ROC curve: McClish's pAUC index is not well defined")
return(MCpA.roc)
}
fbootT<- function(dataset,bssample, low.limit, up.limit){
SpAUC <- NULL
bsdata <- dataset[bssample,]
for (i in 2:dim(bsdata)[2]) {
bsdata_temp <- cbind(bsdata[,1],bsdata[,i])
sen.roc<- points_curve(bsdata_temp[,1],bsdata_temp[,2])[,2]
fpr.roc<- points_curve(bsdata_temp[,1],bsdata_temp[,2])[,1]
fpr.proc <- portion_ROC(up.limit, low.limit, fpr.roc,sen.roc)[,1]
sen.proc <- portion_ROC(up.limit, low.limit, fpr.roc,sen.roc)[,2]
SpAUC[i-1] <- TpA(fpr.proc,sen.proc)
}
return(SpAUC)
}
fbootM<- function(dataset,bssample, low.limit, up.limit){
SpAUC <- NULL
bsdata <- dataset[bssample,]
for (i in 2:dim(bsdata)[2]) {
bsdata_temp <- cbind(bsdata[,1],bsdata[,i])
sen.roc<- points_curve(bsdata_temp[,1],bsdata_temp[,2])[,2]
fpr.roc<- points_curve(bsdata_temp[,1],bsdata_temp[,2])[,1]
fpr.proc <- portion_ROC(up.limit, low.limit, fpr.roc,sen.roc)[,1]
sen.proc <- portion_ROC(up.limit, low.limit, fpr.roc,sen.roc)[,2]
SpAUC[i-1] <- MCpA(sen.proc,fpr.proc)
}
return(SpAUC)
}
createSE <- function(object, names){
names(object) <- names
names <- names
data.matrix <- as.matrix(object)
#cambiar
se=SummarizedExperiment::SummarizedExperiment(assays=data.matrix,
colData<-data.frame(metrics = (names)))
names(se@assays@data@listData[[1]]) <- names
return(se)
}
library("fission")
library(BiocStyle)
library("rms")
library(caret)
library("ROCpAI")
library(preprocessCore)
install.packages("preprocessCore")
data("fission")
fission.expresion <- assay(fission)
fission
dim(fission.expresion)
fission.expresion <- t(fission.expresion)
fission.expresion.normal = scale(as.matrix(fission.expresion), center = TRUE, scale = TRUE)
colnames(fission.expresion.normal)
dim(fission.expresion.normal)
View(fission.final[,1:10])
fission.tipo <- fission@colData@listData$strain
##
fission.final <- cbind(fission.expresion.normal,fission.tipo)
dim(fission.final)
fission.final <- as.data.frame(fission.final)
fission.final[,1]
####obtenciÃ³n de genes mÃ¡s representativos
set.seed(001)
subsets <- c(5,10,15,20)
seeds <- vector(mode = "list", length = 11)
for(i in 1:10) seeds[[i]] <- sample.int(1000, length(subsets) + 1)
seeds[[11]] <- sample.int(1000, 1)
ctrl <- rfeControl(functions=rfFuncs, method = "cv",
number = 3, returnResamp="final",
seeds = seeds,
verbose = TRUE)
fission.rf.profile <- rfe(fission.final[,7040]~., data=fission.final[,-7040],sizes=subsets, rfeControl=ctrl)
fission.genes <- fission.rf.profile$optVariables
fission.expresion.genes.buenos <- fission.final[,fission.genes[1:5]]
fission.expresion.genes.buenos <- as.matrix(fission.expresion.genes.buenos)
fission.datos.genes <- cbind(fission.tipo,fission.expresion.genes.buenos)
colnames(fission.datos.genes) <- c("labels","gen1","gen2","gen3","gen4","gen5")
####test de las funciones
TpAUC.fission.genes <- TpAUC(fission, plot=TRUE, low.value = 0, up.value = 0.15,
selection = c("SPNCRNA.1080","SPAC186.08c","SPNCRNA.1420","SPCC70.08c"),
variable = "strain")
par(new=FALSE)
title("pCurve - Fission dataset")
par(new=TRUE)
McpAUC.fission.genes <- McpAUC(fission, plot=TRUE, low.value = 0, up.value = 0.15,
selection = c("SPNCRNA.1420","SPCC70.08c"),
variable = "strain")
par(new=FALSE)
title("pCurve - Fission dataset")
par(new=TRUE)
prueba <- (assay(TpAUC.fission.genes))
prueba$St_pAUC
prueba$pAUC
prueba$Sensitivity[1]
prueba2 <- (assay(McpAUC.fission.genes))
prueba2$St_pAUC
prueba2$pAUC
points_curve()
sen.proc<- points_curve(fission.datos.genes[,1],fission.datos.genes[,2])[,2]
fpr.proc<- points_curve(fission.datos.genes[,1],fission.datos.genes[,2])[,1]
xx <- TpAUCboot(fission,low.value = 0, up.value = 0.2, seed = 1234, selection=c("SPNCRNA.1080","SPAC186.08c","SPNCRNA.1420","SPCC70.08c"), variable="strain" )
xx <- assay(xx)
x <- matrix(c(xx$Tp_AUC,xx$lwr,xx$upr),ncol = 4,nrow = 3)
colnames(x) <- c("SPNCRNA.1080","SPAC186.08c","SPNCRNA.1420","SPCC70.08c" )
boxplot(x, title("Intervalo de confianza"))
boxplot(x)
boxplot(x, title("Intervalo de confianza"))
